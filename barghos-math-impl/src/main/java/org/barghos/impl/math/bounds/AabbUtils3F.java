package org.barghos.impl.math.bounds;

import org.barghos.annotation.ExtractionParam;
import org.barghos.api.core.function.floats.IFunc6F;
import org.barghos.api.core.math.MathUtils;
import org.barghos.api.core.tuple.floats.ITup3RF;

public class AabbUtils3F
{
	public static <T extends IAabb3WF> T mergeAabbAabb(IAabb3RF aabb1, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbAabb(IAabb3RF aabb1, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbAabb(float[] aabb1, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbAabb(float[] aabb1, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ,  @ExtractionParam T res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, float[] aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam T res)
	{
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}

	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam T res)
	{
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam T res)
	{
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] mergeAabbAabb(IAabb3RF aabb1, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbAabb(IAabb3RF aabb1, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbAabb(float[] aabb1, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbAabb(float[] aabb1, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeAabbVec(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ,  @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, float[] aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecAabb(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}

	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, @ExtractionParam float[] res)
	{
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] mergeVecVec(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, @ExtractionParam float[] res)
	{
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T mergeAabbAabbFunc(IAabb3RF aabb1, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbAabbFunc(IAabb3RF aabb1, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(IAabb3RF aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1.minX();
		float aabb1MinY = aabb1.minY();
		float aabb1MinZ = aabb1.minZ();
		float aabb1MaxX = aabb1.maxX();
		float aabb1MaxY = aabb1.maxY();
		float aabb1MaxZ = aabb1.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbAabbFunc(float[] aabb1, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbAabbFunc(float[] aabb1, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeAabbVecFunc(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeAabbVecFunc(float[] aabb1, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ,  IFunc6F<T> func)
	{
		float aabb1MinX = aabb1[0];
		float aabb1MinY = aabb1[1];
		float aabb1MinZ = aabb1[2];
		float aabb1MaxX = aabb1[3];
		float aabb1MaxY = aabb1[4];
		float aabb1MaxZ = aabb1[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, float[] aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(ITup3RF aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min.v0();
		float aabb1MinY = aabb1Min.v1();
		float aabb1MinZ = aabb1Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, ITup3RF aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, float[] aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, float[] aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float[] aabb1Min, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MinX = aabb1Min[0];
		float aabb1MinY = aabb1Min[1];
		float aabb1MinZ = aabb1Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, ITup3RF aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max.v0();
		float aabb1MaxY = aabb1Max.v1();
		float aabb1MaxZ = aabb1Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float[] aabb1Max, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb1MaxX = aabb1Max[0];
		float aabb1MaxY = aabb1Max[1];
		float aabb1MaxZ = aabb1Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, IAabb3RF aabb2, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2.minX();
		float aabb2MinY = aabb2.minY();
		float aabb2MinZ = aabb2.minZ();
		float aabb2MaxX = aabb2.maxX();
		float aabb2MaxY = aabb2.maxY();
		float aabb2MaxZ = aabb2.maxZ();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecAabbFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2[0];
		float aabb2MinY = aabb2[1];
		float aabb2MinZ = aabb2[2];
		float aabb2MaxX = aabb2[3];
		float aabb2MaxY = aabb2[4];
		float aabb2MaxZ = aabb2[5];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, ITup3RF aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min.v0();
		float aabb2MinY = aabb2Min.v1();
		float aabb2MinZ = aabb2Min.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float[] aabb2Min, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float aabb2MinX = aabb2Min[0];
		float aabb2MinY = aabb2Min[1];
		float aabb2MinZ = aabb2Min[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, ITup3RF aabb2Max, IFunc6F<T> func)
	{
		float aabb2MaxX = aabb2Max.v0();
		float aabb2MaxY = aabb2Max.v1();
		float aabb2MaxZ = aabb2Max.v2();
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}

	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float[] aabb2Max, IFunc6F<T> func)
	{
		float aabb2MaxX = aabb2Max[0];
		float aabb2MaxY = aabb2Max[1];
		float aabb2MaxZ = aabb2Max[2];
		
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T mergeVecVecFunc(float aabb1MinX, float aabb1MinY, float aabb1MinZ, float aabb1MaxX, float aabb1MaxY, float aabb1MaxZ, float aabb2MinX, float aabb2MinY, float aabb2MinZ, float aabb2MaxX, float aabb2MaxY, float aabb2MaxZ, IFunc6F<T> func)
	{
		float newMinX = MathUtils.min(aabb1MinX, aabb1MaxX, aabb2MinX, aabb2MaxX);
		float newMinY = MathUtils.min(aabb1MinY, aabb1MaxY, aabb2MinY, aabb2MaxY);
		float newMinZ = MathUtils.min(aabb1MinZ, aabb1MaxZ, aabb2MinZ, aabb2MaxZ);
		float newMaxX = MathUtils.max(aabb1MinX, aabb1MaxX, aabb2MaxX, aabb2MaxX);
		float newMaxY = MathUtils.max(aabb1MinY, aabb1MaxY, aabb2MaxY, aabb2MaxY);
		float newMaxZ = MathUtils.max(aabb1MinZ, aabb1MaxZ, aabb2MaxZ, aabb2MaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T scale(IAabb3RF aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(IAabb3RF aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] scale(IAabb3RF aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(IAabb3RF aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[]res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scale(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T scaleFunc(IAabb3RF aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(IAabb3RF aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float scaledMinX = aabbMinX * scaleX;
		float scaledMinY = aabbMinY * scaleY;
		float scaledMinZ = aabbMinZ * scaleZ;
		float scaledMaxX = aabbMaxX * scaleX;
		float scaledMaxY = aabbMaxY * scaleY;
		float scaledMaxZ = aabbMaxZ * scaleZ;
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam T res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam T res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam T res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam T res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam T res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, @ExtractionParam float[] res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, @ExtractionParam float[] res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, @ExtractionParam float[] res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, @ExtractionParam float[] res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromPivot(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(IAabb3RF aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabb, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float[] scale, IFunc6F<T> func)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float pivotX = pivot.v0();
		float pivotY = pivot.v1();
		float pivotZ = pivot.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, ITup3RF scale, IFunc6F<T> func)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float[] scale, IFunc6F<T> func)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] pivot, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float pivotX = pivot[0];
		float pivotY = pivot[1];
		float pivotZ = pivot[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, ITup3RF scale, IFunc6F<T> func)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float[] scale, IFunc6F<T> func)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromPivotFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float pivotX, float pivotY, float pivotZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float scaledMinX = MathUtils.fma(scaleX, aabbMinX - pivotX, pivotX);
		float scaledMinY = MathUtils.fma(scaleY, aabbMinY - pivotY, pivotY);
		float scaledMinZ = MathUtils.fma(scaleZ, aabbMinZ - pivotZ, pivotZ);
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - pivotX, pivotX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - pivotY, pivotY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - pivotZ, pivotZ);
		
		float newMinX = MathUtils.min(scaledMinX, scaledMaxX);
		float newMinY = MathUtils.min(scaledMinY, scaledMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, scaledMaxX);
		float newMaxY = MathUtils.max(scaledMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(IAabb3RF aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(IAabb3RF aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] scaleFromMin(IAabb3RF aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(IAabb3RF aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T scaleFromMinFunc(IAabb3RF aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(IAabb3RF aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float scaledMaxX = MathUtils.fma(scaleX, aabbMaxX - aabbMinX, aabbMinX);
		float scaledMaxY = MathUtils.fma(scaleY, aabbMaxY - aabbMinY, aabbMinY);
		float scaledMaxZ = MathUtils.fma(scaleZ, aabbMaxZ - aabbMinZ, aabbMinZ);
		
		float newMinX = MathUtils.min(aabbMinX, scaledMaxX);
		float newMinY = MathUtils.min(aabbMinY, scaledMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, scaledMaxZ);
		float newMaxX = MathUtils.max(aabbMinX, scaledMaxX);
		float newMaxY = MathUtils.max(aabbMinY, scaledMaxY);
		float newMaxZ = MathUtils.max(aabbMinZ, scaledMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(IAabb3RF aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(IAabb3RF aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabb, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabb, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam T res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam T res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam T res)
	{
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] scaleFromMax(IAabb3RF aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(IAabb3RF aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabb, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabb, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabb, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, @ExtractionParam float[] res)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, @ExtractionParam float[] res)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] scaleFromMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, @ExtractionParam float[] res)
	{
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T scaleFromMaxFunc(IAabb3RF aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(IAabb3RF aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(IAabb3RF aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabb, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabb, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabb, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[0];
		float aabbMinZ = aabb[0];
		float aabbMaxX = aabb[0];
		float aabbMaxY = aabb[0];
		float aabbMaxZ = aabb[0];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] scale, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF scale, IFunc6F<T> func)
	{
		float scaleX = scale.v0();
		float scaleY = scale.v1();
		float scaleZ = scale.v2();
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] scale, IFunc6F<T> func)
	{
		float scaleX = scale[0];
		float scaleY = scale[1];
		float scaleZ = scale[2];
		
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T scaleFromMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float scaleX, float scaleY, float scaleZ, IFunc6F<T> func)
	{
		float scaledMinX = MathUtils.fma(scaleX, -aabbMaxX + aabbMinX, aabbMaxX);
		float scaledMinY = MathUtils.fma(scaleY, -aabbMaxY + aabbMinY, aabbMaxY);
		float scaledMinZ = MathUtils.fma(scaleZ, -aabbMaxZ + aabbMinZ, aabbMaxZ);
		
		float newMinX = MathUtils.min(scaledMinX, aabbMaxX);
		float newMinY = MathUtils.min(scaledMinY, aabbMaxY);
		float newMinZ = MathUtils.min(scaledMinZ, aabbMaxZ);
		float newMaxX = MathUtils.max(scaledMinX, aabbMaxX);
		float newMaxY = MathUtils.max(scaledMinY, aabbMaxY);
		float newMaxZ = MathUtils.max(scaledMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T translate(IAabb3RF aabb, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(IAabb3RF aabb, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(IAabb3RF aabb, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabb, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabb, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabb, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, ITup3RF aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float[] aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float[] aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, ITup3RF aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, ITup3RF aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float[] aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float[] aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF t, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] t, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam T res)
	{
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam T res)
	{
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static <T extends IAabb3WF> T translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] translate(IAabb3RF aabb, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(IAabb3RF aabb, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(IAabb3RF aabb, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabb, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabb, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabb, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, ITup3RF aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float[] aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float[] aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, ITup3RF aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, ITup3RF aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float[] aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float[] aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF t, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] t, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, @ExtractionParam float[] res)
	{
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, @ExtractionParam float[] res)
	{
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static float[] translate(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T translateFunc(IAabb3RF aabb, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(IAabb3RF aabb, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(IAabb3RF aabb, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb.minX();
		float aabbMinY = aabb.minY();
		float aabbMinZ = aabb.minZ();
		float aabbMaxX = aabb.maxX();
		float aabbMaxY = aabb.maxY();
		float aabbMaxZ = aabb.maxZ();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabb, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabb, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabb, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabb[0];
		float aabbMinY = aabb[1];
		float aabbMinZ = aabb[2];
		float aabbMaxX = aabb[3];
		float aabbMaxY = aabb[4];
		float aabbMaxZ = aabb[5];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, ITup3RF aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, ITup3RF aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float[] aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float[] aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float[] aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(ITup3RF aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin.v0();
		float aabbMinY = aabbMin.v1();
		float aabbMinZ = aabbMin.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, ITup3RF aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, ITup3RF aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, ITup3RF aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float[] aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float[] aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float[] aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float[] aabbMin, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMinX = aabbMin[0];
		float aabbMinY = aabbMin[1];
		float aabbMinZ = aabbMin[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, ITup3RF aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax.v0();
		float aabbMaxY = aabbMax.v1();
		float aabbMaxZ = aabbMax.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, ITup3RF t, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t.v0();
		float tY = t.v1();
		float tZ = t.v2();
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float[] t, IFunc6F<T> func)
	{
		float aabbMaxX = aabbMax[0];
		float aabbMaxY = aabbMax[1];
		float aabbMaxZ = aabbMax[2];
		
		float tX = t[0];
		float tY = t[1];
		float tZ = t[2];
		
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float[] aabbMax, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		return translateFunc(aabbMinX, aabbMinY, aabbMinZ, aabbMax[0], aabbMax[1], aabbMax[2], tX, tY, tZ, func);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, ITup3RF t, IFunc6F<T> func)
	{
		return translateFunc(aabbMinX, aabbMinY, aabbMinZ, aabbMaxX, aabbMaxY, aabbMaxZ, t.v0(), t.v1(), t.v2(), func);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float[] t, IFunc6F<T> func)
	{
		return translateFunc(aabbMinX, aabbMinY, aabbMinZ, aabbMaxX, aabbMaxY, aabbMaxZ, t[0], t[1], t[2], func);
	}
	
	public static <T> T translateFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float newMinX = aabbMinX + tX;
		float newMinY = aabbMinY + tY;
		float newMinZ = aabbMinZ + tZ;
		float newMaxX = aabbMaxX + tX;
		float newMaxY = aabbMaxY + tY;
		float newMaxZ = aabbMaxZ + tZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T translateMin(float[] aabb, ITup3RF t, @ExtractionParam T res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), res);
	}
	
	public static <T extends IAabb3WF> T translateMin(float[] aabb, float[] t, @ExtractionParam T res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], res);
	}
	
	public static <T extends IAabb3WF> T translateMin(float[] aabb, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, res);
	}
	
	public static <T extends IAabb3WF> T translateMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float translatedMinX = aabbMinX + tX;
		float translatedMinY = aabbMinY + tY;
		float translatedMinZ = aabbMinZ + tZ;
		
		float newMinX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMinY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMinZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		float newMaxX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMaxY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMaxZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] translateMin(float[] aabb, ITup3RF t, @ExtractionParam float[] res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), res);
	}
	
	public static float[] translateMin(float[] aabb, float[] t, @ExtractionParam float[] res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], res);
	}
	
	public static float[] translateMin(float[] aabb, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		return translateMin(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, res);
	}
	
	public static float[] translateMin(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float translatedMinX = aabbMinX + tX;
		float translatedMinY = aabbMinY + tY;
		float translatedMinZ = aabbMinZ + tZ;
		
		float newMinX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMinY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMinZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		float newMaxX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMaxY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMaxZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T translateMinFunc(float[] aabb, ITup3RF t, IFunc6F<T> func)
	{
		return translateMinFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), func);
	}
	
	public static <T> T translateMinFunc(float[] aabb, float[] t, IFunc6F<T> func)
	{
		return translateMinFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], func);
	}
	
	public static <T> T translateMinFunc(float[] aabb, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		return translateMinFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, func);
	}
	
	public static <T> T translateMinFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float translatedMinX = aabbMinX + tX;
		float translatedMinY = aabbMinY + tY;
		float translatedMinZ = aabbMinZ + tZ;
		
		float newMinX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMinY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMinZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		float newMaxX = MathUtils.min(translatedMinX, aabbMaxX);
		float newMaxY = MathUtils.min(translatedMinY, aabbMaxY);
		float newMaxZ = MathUtils.min(translatedMinZ, aabbMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T translateMax(float[] aabb, ITup3RF t, @ExtractionParam T res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), res);
	}
	
	public static <T extends IAabb3WF> T translateMax(float[] aabb, float[] t, @ExtractionParam T res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], res);
	}
	
	public static <T extends IAabb3WF> T translateMax(float[] aabb, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, res);
	}
	
	public static <T extends IAabb3WF> T translateMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam T res)
	{
		float translatedMaxX = aabbMaxX + tX;
		float translatedMaxY = aabbMaxY + tY;
		float translatedMaxZ = aabbMaxZ + tZ;
		
		float newMinX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMinY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		float newMaxX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMaxY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMaxZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] translateMax(float[] aabb, ITup3RF t, @ExtractionParam float[] res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), res);
	}
	
	public static float[] translateMax(float[] aabb, float[] t, @ExtractionParam float[] res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], res);
	}
	
	public static float[] translateMax(float[] aabb, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		return translateMax(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, res);
	}
	
	public static float[] translateMax(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, @ExtractionParam float[] res)
	{
		float translatedMaxX = aabbMaxX + tX;
		float translatedMaxY = aabbMaxY + tY;
		float translatedMaxZ = aabbMaxZ + tZ;
		
		float newMinX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMinY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		float newMaxX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMaxY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMaxZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T translateMaxFunc(float[] aabb, ITup3RF t, IFunc6F<T> func)
	{
		return translateMaxFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t.v0(), t.v1(), t.v2(), func);
	}
	
	public static <T> T translateMaxFunc(float[] aabb, float[] t, IFunc6F<T> func)
	{
		return translateMaxFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], t[0], t[1], t[2], func);
	}
	
	public static <T> T translateMaxFunc(float[] aabb, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		return translateMaxFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], tX, tY, tZ, func);
	}
	
	public static <T> T translateMaxFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float tX, float tY, float tZ, IFunc6F<T> func)
	{
		float translatedMaxX = aabbMaxX + tX;
		float translatedMaxY = aabbMaxY + tY;
		float translatedMaxZ = aabbMaxZ + tZ;
		
		float newMinX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMinY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMinZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		float newMaxX = MathUtils.min(aabbMinX, translatedMaxX);
		float newMaxY = MathUtils.min(aabbMinY, translatedMaxY);
		float newMaxZ = MathUtils.min(aabbMinZ, translatedMaxZ);
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T grow(float[] aabb, ITup3RF e, @ExtractionParam T res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e.v0(), e.v1(), e.v2(), res);
	}
	
	public static <T extends IAabb3WF> T grow(float[] aabb, float[] e, @ExtractionParam T res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], res);
	}
	
	public static <T extends IAabb3WF> T grow(float[] aabb, float eX, float eY, float eZ, @ExtractionParam T res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eX, eY, eZ, res);
	}
	
	public static <T extends IAabb3WF> T grow(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eX, float eY, float eZ, @ExtractionParam T res)
	{
		float newMinX = aabbMinX - eX;
		float newMinY = aabbMinY - eY;
		float newMinZ = aabbMinZ - eZ;
		float newMaxX = aabbMaxX + eX;
		float newMaxY = aabbMaxY + eY;
		float newMaxZ = aabbMaxZ + eZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] grow(float[] aabb, ITup3RF e, @ExtractionParam float[] res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e.v0(), e.v1(), e.v2(), res);
	}
	
	public static float[] grow(float[] aabb, float[] e, @ExtractionParam float[] res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], res);
	}
	
	public static float[] grow(float[] aabb, float eX, float eY, float eZ, @ExtractionParam float[] res)
	{
		return grow(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eX, eY, eZ, res);
	}
	
	public static float[] grow(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eX, float eY, float eZ, @ExtractionParam float[] res)
	{
		float newMinX = aabbMinX - eX;
		float newMinY = aabbMinY - eY;
		float newMinZ = aabbMinZ - eZ;
		float newMaxX = aabbMaxX + eX;
		float newMaxY = aabbMaxY + eY;
		float newMaxZ = aabbMaxZ + eZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T growFunc(float[] aabb, ITup3RF e, IFunc6F<T> func)
	{
		return growFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e.v0(), e.v1(), e.v2(), func);
	}
	
	public static <T> T growFunc(float[] aabb, float[] e, IFunc6F<T> func)
	{
		return growFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], func);
	}
	
	public static <T> T growFunc(float[] aabb, float eX, float eY, float eZ, IFunc6F<T> func)
	{
		return growFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eX, eY, eZ, func);
	}
	
	public static <T> T growFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eX, float eY, float eZ, IFunc6F<T> func)
	{
		float newMinX = aabbMinX - eX;
		float newMinY = aabbMinY - eY;
		float newMinZ = aabbMinZ - eZ;
		float newMaxX = aabbMaxX + eX;
		float newMaxY = aabbMaxY + eY;
		float newMaxZ = aabbMaxZ + eZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
	
	public static <T extends IAabb3WF> T expand(float[] aabb, float[] e, @ExtractionParam T res)
	{
		return expand(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], e[3], e[4], e[5], res);
	}
	
	public static <T extends IAabb3WF> T expand(float[] aabb, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, @ExtractionParam T res)
	{
		return expand(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eMinX, eMinY, eMinZ, eMaxX, eMaxY, eMaxZ, res);
	}
	
	public static <T extends IAabb3WF> T expand(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, @ExtractionParam T res)
	{
		float newMinX = aabbMinX - eMinX;
		float newMinY = aabbMinY - eMinY;
		float newMinZ = aabbMinZ - eMinZ;
		float newMaxX = aabbMaxX + eMaxX;
		float newMaxY = aabbMaxY + eMaxY;
		float newMaxZ = aabbMaxZ + eMaxZ;
		
		res.set(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
		
		return res;
	}
	
	public static float[] expand(float[] aabb, float[] e, @ExtractionParam float[] res)
	{
		return expand(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], e[3], e[4], e[5], res);
	}
	
	public static float[] expand(float[] aabb, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, @ExtractionParam float[] res)
	{
		return expand(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eMinX, eMinY, eMinZ, eMaxX, eMaxY, eMaxZ, res);
	}
	
	public static float[] expand(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, @ExtractionParam float[] res)
	{
		float newMinX = aabbMinX - eMinX;
		float newMinY = aabbMinY - eMinY;
		float newMinZ = aabbMinZ - eMinZ;
		float newMaxX = aabbMaxX + eMaxX;
		float newMaxY = aabbMaxY + eMaxY;
		float newMaxZ = aabbMaxZ + eMaxZ;
		
		res[0] = newMinX;
		res[1] = newMinY;
		res[2] = newMinZ;
		res[3] = newMaxX;
		res[4] = newMaxY;
		res[5] = newMaxZ;
		
		return res;
	}
	
	public static <T> T expandFunc(float[] aabb, float[] e, IFunc6F<T> func)
	{
		return expandFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], e[0], e[1], e[2], e[3], e[4], e[5], func);
	}
	
	public static <T> T expandFunc(float[] aabb, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, IFunc6F<T> func)
	{
		return expandFunc(aabb[0], aabb[1], aabb[2], aabb[3], aabb[4], aabb[5], eMinX, eMinY, eMinZ, eMaxX, eMaxY, eMaxZ, func);
	}
	
	public static <T> T expandFunc(float aabbMinX, float aabbMinY, float aabbMinZ, float aabbMaxX, float aabbMaxY, float aabbMaxZ, float eMinX, float eMinY, float eMinZ, float eMaxX, float eMaxY, float eMaxZ, IFunc6F<T> func)
	{
		float newMinX = aabbMinX - eMinX;
		float newMinY = aabbMinY - eMinY;
		float newMinZ = aabbMinZ - eMinZ;
		float newMaxX = aabbMaxX + eMaxX;
		float newMaxY = aabbMaxY + eMaxY;
		float newMaxZ = aabbMaxZ + eMaxZ;
		
		return func.apply(newMinX, newMinY, newMinZ, newMaxX, newMaxY, newMaxZ);
	}
}
